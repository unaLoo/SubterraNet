<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="https://cesium.com/downloads/cesiumjs/releases/1.126/Build/Cesium/Cesium.js"></script>
    <link href="https://cesium.com/downloads/cesiumjs/releases/1.126/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
</head>

<body>
    <div id="cesiumContainer" class="fullSize"></div>

    <script>

        Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiIzMDUxNDNkNy02MmM3LTQ4ZjctYmFkYy1mMTllNTU4YmIzNWEiLCJpZCI6ODc3MjIsImlhdCI6MTc0MDY2NTEwNX0.uiI6vJyFTd6xIxjdTBTcXpjDkpdmyCx6g-4FLjfQtXw'

        // Initialize the Cesium Viewer in the HTML element with the `cesiumContainer` ID.
        const viewer = new Cesium.Viewer('cesiumContainer', {
            terrain: Cesium.Terrain.fromWorldTerrain(),
        });

        // Fly the camera to San Francisco at the given longitude, latitude, and height.
        viewer.camera.flyTo({
            destination: Cesium.Cartesian3.fromDegrees(114.02467656894675, 22.44434758616074, 2000),
            orientation: {
                heading: Cesium.Math.toRadians(0.0),
                pitch: Cesium.Math.toRadians(-15.0),
            }
        });



        var tilesetModel = new Cesium.Cesium3DTileset({
            url: "http://127.0.0.1:8080/tileset.json"
        });
        viewer.scene.primitives.add(tilesetModel);

        // tileset = viewer.scene.primitives.add(new Cesium.Cesium3DTileset({ url: 'http://127.0.0.1:8080/tileset.json' }));
        // viewer.scene.globe.depthTestAgainstTerrain = true;
        // console.log(tileset)
        // tileset.readyPromise.then(function (tileset) {
        //     let boundingSphere = tileset.boundingSphere; // 模型的范围
        //     let cartographic = Cesium.Cartographic.fromCartesian(boundingSphere.center); // 从笛卡尔位置创建一个新的位置实例（返回的是一个经纬度的）
        //     let surface = Cesium.Cartesian3.fromRadians(cartographic.longitude, cartographic.latitude, 0.0); // 以经纬度的值来返回Cartesian3(xyz)的位置 ，/
        //     let offset = Cesium.Cartesian3.fromRadians(cartographic.longitude, cartographic.latitude, 50); // 以经纬度的值来返回Cartesian3(xyz)的位置 ，//>
        //     let translation = Cesium.Cartesian3.subtract(offset, surface, new Cesium.Cartesian3()); // 计算两个笛卡尔的分量差异。
        //     tileset.modelMatrix = Cesium.Matrix4.fromTranslation(translation);
        //     viewer.zoomTo(tileset);
        // });


    </script>

</body>

</html>